<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sheeran Looper Pro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">

    <style>
        /* --- Base Styles & Theme --- */
        :root {
            --color-background: #1a1a1a;
            --color-pedal: #2b2b2b;
            --color-pedal-border: #444;
            --color-text: #e0e0e0;
            --color-glow-record: #ff4141;
            --color-glow-play: #41ff6b;
            --color-glow-armed: #ffc400;
            --color-glow-overdub: #ff8c00;
            --color-led-off: #333;
            --color-led-record: #ff1818;
            --color-led-play: #18ff62;
            --color-led-armed: #ffc400;
            --color-led-overdub: #ff8c00;
            --color-mute: #ffc400;
            --color-master: #ffffff;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--color-background);
            color: var(--color-text);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        #status-display {
            min-height: 24px;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            color: #aaa;
            transition: color 0.3s;
        }
        
        #global-progress-bar-container {
            width: 100%;
            height: 6px;
            background-color: #333;
            border-radius: 3px;
            margin-bottom: 1.5rem;
            overflow: hidden;
        }

        #global-progress-bar {
            width: 0%;
            height: 100%;
            background-color: var(--color-glow-play);
            border-radius: 3px;
        }

        /* --- Master Controls --- */
        .master-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            background: #222;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 1.5rem;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label { font-weight: 600; }

        .control-group input[type="number"], .control-group select {
            background: #333; border: 1px solid #555;
            color: var(--color-text); border-radius: 5px; padding: 5px;
        }

        .control-group input[type="number"] { width: 70px; }

        .styled-button {
            padding: 8px 12px; border: 1px solid #777; background-color: #444;
            border-radius: 5px; cursor: pointer; color: var(--color-text);
        }
        .styled-button.active {
            background-color: var(--color-glow-play); color: #111;
            border-color: var(--color-glow-play);
        }

        /* --- Pedal Board & Pedals --- */
        .pedal-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 25px;
            margin-bottom: 1.5rem;
        }

        .pedal {
            position: relative;
            aspect-ratio: 1 / 1.2;
            background: linear-gradient(145deg, #3c3c3c, #222);
            border: 2px solid var(--color-pedal-border);
            border-radius: 12px; cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5), inset 0 2px 2px rgba(255,255,255,0.05);
            display: flex; flex-direction: column;
            justify-content: space-between; padding: 8px;
        }
        
        .pedal.master-loop { box-shadow: 0 0 10px var(--color-master), inset 0 0 5px var(--color-master); }

        .pedal-header {
            width: 100%; display: flex;
            justify-content: space-between; align-items: center;
        }

        .pedal-number { font-size: 1.5rem; font-weight: 600; color: #888; }
        .led { width: 15px; height: 15px; background-color: var(--color-led-off); border-radius: 50%; border: 2px solid #111; }
        .mute-btn { font-size: 0.8rem; font-weight: 600; background: #555; color: #ccc; border: 1px solid #777; border-radius: 5px; padding: 2px 6px; cursor: pointer; z-index: 10; }
        .mute-btn.muted { background: var(--color-mute); color: #111; border-color: var(--color-mute); }

        .waveform-container { position: relative; width: 100%; height: 50%; }
        .waveform-canvas { width: 100%; height: 100%; }
        .progress-overlay { position: absolute; top: 0; left: 0; height: 100%; width: 0; background-color: rgba(65, 255, 107, 0.2); mix-blend-mode: lighten; }
        .countdown-display { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2.5rem; font-weight: 600; color: white; text-shadow: 0 0 8px black; pointer-events: none; }

        .pedal-footer { display: flex; gap: 5px; align-items: center; padding: 0 5px; }
        .pedal-footer label { font-size: 0.7rem; }
        .pedal-footer input[type="range"] { flex-grow: 1; }

        /* Pedal States */
        .pedal.armed { border-color: var(--color-glow-armed); animation: pulse-armed 1.5s infinite; }
        .pedal.armed .led { background-color: var(--color-led-armed); box-shadow: 0 0 10px var(--color-led-armed); }
        .pedal.recording { border-color: var(--color-glow-record); animation: pulse-record 1.5s infinite; }
        .pedal.recording .led { background-color: var(--color-led-record); box-shadow: 0 0 10px var(--color-led-record); }
        .pedal.overdubbing { border-color: var(--color-glow-overdub); animation: pulse-overdub 1.5s infinite; }
        .pedal.overdubbing .led { background-color: var(--color-led-overdub); box-shadow: 0 0 10px var(--color-led-overdub); }
        .pedal.playing { border-color: var(--color-glow-play); }
        .pedal.playing .led { background-color: var(--color-led-play); box-shadow: 0 0 10px var(--color-led-play); }

        @keyframes pulse-record { 50% { box-shadow: 0 0 35px var(--color-glow-record); } }
        @keyframes pulse-armed { 50% { box-shadow: 0 0 35px var(--color-glow-armed); } }
        @keyframes pulse-overdub { 50% { box-shadow: 0 0 35px var(--color-glow-overdub); } }

        /* --- Footer Controls --- */
        .session-controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 1rem; }
        .session-controls button {
            padding: 10px 20px; font-size: 1rem; font-weight: 600; color: var(--color-text);
            border-radius: 8px; cursor: pointer; transition: all 0.2s;
        }
        #master-stop-btn { background-color: #800; border: 2px solid #c00; }
        #master-stop-btn:hover { background-color: #a00; border-color: #f33; box-shadow: 0 0 15px #f33; }
        #undo-btn { background-color: #a50; border: 2px solid #d80; }
        #undo-btn:hover { background-color: #d80; border-color: #fa0; box-shadow: 0 0 15px #fa0; }
        
        #help-btn { position: fixed; top: 15px; right: 15px; width: 40px; height: 40px; border-radius: 50%; background: #333; border: 2px solid #666; font-size: 1.5rem; font-weight: 600; cursor: pointer; }

        /* --- Modal --- */
        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.7);
        }
        .modal-content {
            background-color: #2d2d2d; margin: 10% auto; padding: 25px; border: 1px solid #888;
            width: 80%; max-width: 600px; border-radius: 10px; color: var(--color-text);
        }
        .modal-content h2 { margin-top: 0; }
        .modal-content code { background: #444; padding: 2px 5px; border-radius: 3px; }
        .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }

        @media (max-width: 800px) {
            .pedal-board { grid-template-columns: repeat(2, 1fr); }
            .master-controls { flex-direction: column; gap: 15px; }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Sheeran Looper Pro</h1>
        <p id="status-display">Connect MIDI or click a pedal to start.</p>
        
        <div id="global-progress-bar-container"><div id="global-progress-bar"></div></div>

        <div class="master-controls">
            <div class="control-group">
                <label for="bpm-input">BPM:</label>
                <input type="number" id="bpm-input" value="120" min="40" max="240">
                <button id="metronome-toggle" class="styled-button">Metronome</button>
            </div>
            <div class="control-group">
                 <label for="midi-input-select">MIDI In:</label>
                 <select id="midi-input-select"></select>
            </div>
             <div class="control-group">
                <label for="count-in-toggle">Count-In:</label>
                <button id="count-in-toggle" class="styled-button">Off</button>
            </div>
        </div>

        <div class="pedal-board" id="pedal-board"></div>
        
        <div class="session-controls">
            <button id="undo-btn">Undo Last</button>
            <button id="master-stop-btn">Stop All</button>
        </div>
        
        <p class="shortcuts-help">
            <b>Keys:</b> [1-8] Pedal Action | [Dbl-Click 1-8] Stop Pedal | [Shift+1-8] Mute | [SPACE] Stop All
        </p>
    </div>

    <button id="help-btn">?</button>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2>MIDI Control Setup (Arturia MiniLab 3)</h2>
            <p>To use your MiniLab 3 for hands-free looping, you need to configure its pads to send the correct MIDI messages. This can be done using Arturia's free "MIDI Control Center" software.</p>
            <h4>Recommended Pad Configuration:</h4>
            <ol>
                <li><strong>Open MIDI Control Center</strong> and connect your MiniLab 3.</li>
                <li>Select one of the User memory slots to edit.</li>
                <li><strong>Set Pad Mode:</strong> For each of the 8 pads, set the "Mode" to <code>Note</code>.</li>
                <li><strong>Assign MIDI Notes:</strong>
                    <ul>
                        <li>Assign Pad 1 to send MIDI Note <code>C1</code> (Note Number 36).</li>
                        <li>Assign Pad 2 to send MIDI Note <code>C#1</code> (Note Number 37).</li>
                        <li>...continue sequentially up to Pad 8 sending <code>G1</code> (Note Number 43).</li>
                    </ul>
                </li>
                 <li><strong>Set Channel:</strong> Ensure all pads are sending on the same MIDI Channel. Channel 10 is common for drums/pads, but any channel will work.</li>
                <li><strong>Save to Device:</strong> Once configured, save the preset back to your MiniLab's user memory slot.</li>
            </ol>
            <h4>Default Controls:</h4>
            <ul>
                <li><strong>Pads 1-8 (Notes 36-43):</strong> Main pedal action (Record / Overdub / Stop).</li>
                <li>The application will automatically detect your controller. Just select it from the "MIDI In" dropdown after connecting it.</li>
            </ul>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const pedalBoard = document.getElementById('pedal-board');
            const statusDisplay = document.getElementById('status-display');
            const masterStopBtn = document.getElementById('master-stop-btn');
            const undoBtn = document.getElementById('undo-btn');
            const bpmInput = document.getElementById('bpm-input');
            const metronomeToggle = document.getElementById('metronome-toggle');
            const countInToggle = document.getElementById('count-in-toggle');
            const midiSelect = document.getElementById('midi-input-select');
            const globalProgressBar = document.getElementById('global-progress-bar');
            const helpBtn = document.getElementById('help-btn');
            const helpModal = document.getElementById('help-modal');
            const closeModalBtn = helpModal.querySelector('.close-btn');

            // --- State ---
            const NUM_PEDALS = 8;
            let pedals = [];
            let isMicAccessGranted = false;
            let mediaStream = null;
            let masterLoopIndex = -1;
            let nextBeatTime = 0;
            let beatNumber = 0;
            let schedulerTimerID;
            let isMetronomeOn = false;
            let isCountInEnabled = false;
            let lastRecordedPedalIndex = -1;
            let clickTimeout = null;

            // --- Web Audio API ---
            let audioContext;
            let masterGainNode;

            function initAudioContext() {
                if (audioContext && audioContext.state === 'running') return;
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.value = 0.8;
                masterGainNode.connect(audioContext.destination);
            }

            // --- Metronome & Scheduler ---
            function metronomeScheduler() {
                while (nextBeatTime < audioContext.currentTime + 0.1) {
                    if (isMetronomeOn) playMetronomeClick(nextBeatTime);
                    pedals.forEach((p, index) => {
                        if (p.countdown > 0) {
                            p.countdown--;
                            updateCountdownDisplay(index, p.countdown > 0 ? p.countdown : 'REC');
                            if(p.countdown === 0) {
                                setTimeout(() => updateCountdownDisplay(index, ''), 500);
                            }
                        }
                    });
                    nextBeatTime += 60.0 / bpmInput.value;
                    beatNumber++;
                }
                schedulerTimerID = window.setTimeout(metronomeScheduler, 25.0);
            }

            function playMetronomeClick(time) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(masterGainNode);
                osc.frequency.value = (beatNumber % 4 === 0) ? 1000 : 800;
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                osc.start(time);
                osc.stop(time + 0.05);
            }
            
            // --- Pedal Initialization ---
            function initializePedals() {
                for (let i = 0; i < NUM_PEDALS; i++) {
                    const pedalElements = createPedalElement(i);
                    pedals[i] = {
                        state: 'empty', // empty, armed, recording, playing, overdubbing
                        ...pedalElements,
                        isMuted: false,
                        layers: [],
                        activeSources: [],
                        syncTimeout: null,
                        countdown: 0,
                    };
                    pedalBoard.appendChild(pedalElements.domElement);
                }
            }

            function createPedalElement(index) {
                const domElement = document.createElement('div');
                domElement.className = 'pedal';
                domElement.dataset.index = index;
                domElement.innerHTML = `
                    <div class="pedal-header">
                        <div class="led"></div>
                        <div class="pedal-number">${index + 1}</div>
                        <button class="mute-btn">M</button>
                    </div>
                    <div class="waveform-container">
                        <canvas class="waveform-canvas"></canvas>
                        <div class="progress-overlay"></div>
                        <div class="countdown-display"></div>
                    </div>
                    <div class="pedal-footer">
                        <label>V</label><input type="range" class="volume-slider" min="0" max="1.5" step="0.01" value="1">
                        <label>P</label><input type="range" class="pan-slider" min="-1" max="1" step="0.01" value="0">
                    </div>
                `;
                
                domElement.addEventListener('click', () => {
                    if (clickTimeout !== null) {
                        clearTimeout(clickTimeout);
                        clickTimeout = null;
                        handlePedalDoubleClick(index);
                    } else {
                        clickTimeout = setTimeout(() => {
                           clickTimeout = null;
                           handlePedalClick(index);
                        }, 250); // 250ms window for double click
                    }
                });

                const muteBtn = domElement.querySelector('.mute-btn');
                muteBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleMute(index); });

                const volumeSlider = domElement.querySelector('.volume-slider');
                volumeSlider.addEventListener('input', (e) => {
                    e.stopPropagation();
                    if(pedals[index].gainNode) pedals[index].gainNode.gain.value = e.target.value;
                });
                
                const panSlider = domElement.querySelector('.pan-slider');
                panSlider.addEventListener('input', (e) => {
                    e.stopPropagation();
                    if(pedals[index].pannerNode) pedals[index].pannerNode.pan.value = e.target.value;
                });
                
                return {
                    domElement, muteBtn,
                    canvas: domElement.querySelector('.waveform-canvas'),
                    canvasCtx: domElement.querySelector('.waveform-canvas').getContext('2d'),
                    progressOverlay: domElement.querySelector('.progress-overlay'),
                    countdownDisplay: domElement.querySelector('.countdown-display'),
                };
            }
            
            // --- Core Looping Logic ---
            async function handlePedalClick(index) {
                await initAudioContext();
                if (!isMicAccessGranted) {
                    const hasMic = await getMicAccess();
                    if (!hasMic) return;
                }
                if (!schedulerTimerID) startScheduler();

                const pedal = pedals[index];
                switch (pedal.state) {
                    case 'empty':
                        armForRecording(index);
                        break;
                    case 'armed':
                        cancelArm(index);
                        break;
                    case 'recording':
                    case 'overdubbing':
                        armToStopRecording(index);
                        break;
                    case 'playing':
                        armForOverdub(index);
                        break;
                }
            }

            function handlePedalDoubleClick(index) {
                const pedal = pedals[index];
                if (pedal.state === 'playing' || pedal.state === 'overdubbing') {
                    stopPlaying(index);
                }
            }
            
            function armForRecording(index) {
                const pedal = pedals[index];
                pedal.state = 'armed';
                updatePedalUI(index);

                if (masterLoopIndex !== -1) {
                    const masterLoop = pedals[masterLoopIndex];
                    const timeToLoopStart = (masterLoop.layers[0].buffer.duration - masterLoop.activeSources[0].mediaElement.currentTime) * 1000;
                    statusDisplay.textContent = `Pedal ${index + 1} armed. Waiting for Master Loop...`;
                    pedal.syncTimeout = setTimeout(() => startRecording(index), timeToLoopStart);
                } else {
                    const beatsToWait = isCountInEnabled ? 4 : 0;
                    if (beatsToWait > 0) pedal.countdown = beatsToWait;
                    const timeToStart = (nextBeatTime - audioContext.currentTime + (beatsToWait * (60.0 / bpmInput.value))) * 1000;
                    statusDisplay.textContent = `Pedal ${index + 1} armed. Waiting for beat...`;
                    pedal.syncTimeout = setTimeout(() => startRecording(index), timeToStart);
                }
            }

            function armForOverdub(index) {
                const pedal = pedals[index];
                pedal.state = 'armed';
                updatePedalUI(index);
                const masterLoop = pedals[masterLoopIndex];
                const timeToLoopStart = (masterLoop.layers[0].buffer.duration - masterLoop.activeSources[0].mediaElement.currentTime) * 1000;
                statusDisplay.textContent = `Pedal ${index + 1} armed for overdub...`;
                pedal.syncTimeout = setTimeout(() => startOverdubbing(index), timeToLoopStart);
            }

            function startRecording(index) {
                const pedal = pedals[index];
                if (pedal.state !== 'armed') return;
                pedal.recorder = new MediaRecorder(mediaStream);
                pedal.recorder.start();
                pedal.state = 'recording';
                updatePedalUI(index);
                statusDisplay.textContent = `Recording on Pedal ${index + 1}...`;
            }
            
            function startOverdubbing(index) {
                 const pedal = pedals[index];
                 if (pedal.state !== 'armed') return;
                 pedal.recorder = new MediaRecorder(mediaStream);
                 pedal.recorder.start();
                 pedal.state = 'overdubbing';
                 updatePedalUI(index);
                 statusDisplay.textContent = `Overdubbing on Pedal ${index + 1}...`;
            }

            function armToStopRecording(index) {
                const pedal = pedals[index];
                statusDisplay.textContent = `Arming stop for Pedal ${index + 1}...`;

                if (masterLoopIndex !== -1) {
                    const masterLoop = pedals[masterLoopIndex];
                    const timeToLoopEnd = (masterLoop.layers[0].buffer.duration - masterLoop.activeSources[0].mediaElement.currentTime) * 1000;
                    pedal.syncTimeout = setTimeout(() => stopRecording(index), timeToLoopEnd);
                } else {
                    const timeToNextBeat = (nextBeatTime - audioContext.currentTime) * 1000;
                    pedal.syncTimeout = setTimeout(() => stopRecording(index), timeToNextBeat);
                }
            }
            
            function stopRecording(index) {
                const pedal = pedals[index];
                if ((pedal.state !== 'recording' && pedal.state !== 'overdubbing') || !pedal.recorder || pedal.recorder.state !== 'recording') return;
                pedal.recorder.ondataavailable = e => processRecordedAudio(index, e.data);
                pedal.recorder.stop();
            }

            async function processRecordedAudio(index, audioData) {
                const pedal = pedals[index];
                const audioBlob = new Blob([audioData], { 'type': 'audio/webm;codecs=opus' });
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                pedal.layers.push({ blob: audioBlob, buffer: audioBuffer });
                lastRecordedPedalIndex = index;
                
                if (masterLoopIndex === -1) {
                    masterLoopIndex = index;
                }
                
                // Stop current playback to restart with the new layer
                stopAllSourcesForPedal(index);
                playAllLayers(index);
            }

            function playAllLayers(index) {
                const pedal = pedals[index];
                if (pedal.layers.length === 0) return;

                // Re-create gain/panner nodes if they don't exist
                if (!pedal.gainNode) pedal.gainNode = audioContext.createGain();
                if (!pedal.pannerNode) pedal.pannerNode = audioContext.createStereoPanner();
                pedal.gainNode.gain.value = pedal.domElement.querySelector('.volume-slider').value;
                pedal.pannerNode.pan.value = pedal.domElement.querySelector('.pan-slider').value;
                pedal.gainNode.connect(pedal.pannerNode).connect(masterGainNode);

                pedal.layers.forEach(layer => {
                    const mediaElement = new Audio(URL.createObjectURL(layer.blob));
                    mediaElement.loop = true;
                    const sourceNode = audioContext.createMediaElementSource(mediaElement);
                    sourceNode.connect(pedal.gainNode);
                    mediaElement.play();
                    pedal.activeSources.push({ mediaElement, sourceNode });
                });

                pedal.state = 'playing';
                updatePedalUI(index);
                drawWaveform(index, pedal.layers.length -1); // Draw latest layer
                startProgressBarAnimation(index);
            }

            function stopAllSourcesForPedal(index) {
                const pedal = pedals[index];
                pedal.activeSources.forEach(src => {
                    src.mediaElement.pause();
                    src.mediaElement.remove();
                    src.sourceNode.disconnect();
                });
                pedal.activeSources = [];
            }

            function stopPlaying(index, fullReset = true) {
                const pedal = pedals[index];
                if (pedal.animationFrameId) cancelAnimationFrame(pedal.animationFrameId);
                if (pedal.syncTimeout) clearTimeout(pedal.syncTimeout);

                stopAllSourcesForPedal(index);

                if (fullReset) {
                    pedal.state = 'empty';
                    pedal.layers = [];
                    clearCanvas(index);
                    statusDisplay.textContent = `Loop ${index + 1} stopped & cleared.`;

                    if (index === masterLoopIndex) {
                        masterLoopIndex = pedals.findIndex(p => p.state === 'playing');
                        // if no other loops are playing, reset masterLoopIndex
                         if (masterLoopIndex === -1) {
                            globalProgressBar.style.width = '0%';
                         }
                    }
                } else {
                    pedal.state = 'stopped'; // Or some other state if we want to pause
                }
                updatePedalUI(index);
            }
            
            // --- UI & Visuals ---
            function updatePedalUI(index) {
                const pedal = pedals[index];
                pedal.domElement.className = 'pedal'; // Reset
                if (pedal.state) pedal.domElement.classList.add(pedal.state);
                if (index === masterLoopIndex) pedal.domElement.classList.add('master-loop');
            }

            function updateCountdownDisplay(index, text) {
                pedals[index].countdownDisplay.textContent = text;
            }

            function startProgressBarAnimation(index) {
                const pedal = pedals[index];
                const animate = () => {
                    if (pedal.state !== 'playing' && pedal.state !== 'overdubbing') return;
                    if(pedal.activeSources.length > 0) {
                        const progress = (pedal.activeSources[0].mediaElement.currentTime / pedal.activeSources[0].mediaElement.duration) * 100;
                        pedal.progressOverlay.style.width = `${progress}%`;
                        if (index === masterLoopIndex) {
                           globalProgressBar.style.width = `${progress}%`;
                        }
                    }
                    pedal.animationFrameId = requestAnimationFrame(animate);
                };
                animate();
            }

            function drawWaveform(index, layerIndex) {
                const pedal = pedals[index];
                const layer = pedal.layers[layerIndex];
                if (!layer || !layer.buffer) return;

                const canvas = pedal.canvas;
                const ctx = pedal.canvasCtx;
                const data = layer.buffer.getChannelData(0);
                const width = canvas.width;
                const height = canvas.height;
                const step = Math.ceil(data.length / width);
                const amp = height / 2;

                ctx.clearRect(0, 0, width, height); // Clear previous drawings
                
                // Draw all layers semi-transparently
                pedals[index].layers.forEach((l, i) => {
                    const layerData = l.buffer.getChannelData(0);
                    const isLastLayer = i === pedals[index].layers.length - 1;
                    ctx.lineWidth = isLastLayer ? 1.5 : 1;
                    ctx.strokeStyle = isLastLayer ? 'rgba(65, 255, 107, 1)' : 'rgba(65, 255, 107, 0.3)';
                    ctx.beginPath();
                    for (let x = 0; x < width; x++) {
                        let min = 1.0; let max = -1.0;
                        for (let j = 0; j < step; j++) {
                            const datum = layerData[(x * step) + j];
                            if (datum < min) min = datum;
                            if (datum > max) max = datum;
                        }
                         if (x === 0) {
                             ctx.moveTo(x, (1 + max) * amp);
                         } else {
                             ctx.lineTo(x, (1 + max) * amp);
                         }
                    }
                    ctx.stroke();
                });
            }

            function clearCanvas(index) {
                const p = pedals[index];
                p.canvasCtx.clearRect(0, 0, p.canvas.width, p.canvas.height);
            }

            // --- Master & Utility Functions ---
            function masterStop() {
                for (let i = 0; i < NUM_PEDALS; i++) {
                    if (pedals[i].state !== 'empty') stopPlaying(i);
                }
                masterLoopIndex = -1;
                globalProgressBar.style.width = '0%';
                statusDisplay.textContent = 'All loops stopped.';
            }
            
            function undo() {
                if (lastRecordedPedalIndex === -1) return;
                const pedal = pedals[lastRecordedPedalIndex];
                if (pedal.layers.length > 0) {
                    pedal.layers.pop();
                    stopAllSourcesForPedal(lastRecordedPedalIndex);
                    if(pedal.layers.length > 0) {
                        playAllLayers(lastRecordedPedalIndex);
                    } else {
                        stopPlaying(lastRecordedPedalIndex, true); // True to fully reset
                    }
                }
            }

            function toggleMute(index) {
                const pedal = pedals[index];
                pedal.isMuted = !pedal.isMuted;
                pedal.muteBtn.classList.toggle('muted', pedal.isMuted);
                if (pedal.gainNode) {
                    const volume = pedal.domElement.querySelector('.volume-slider').value;
                    pedal.gainNode.gain.setValueAtTime(pedal.isMuted ? 0 : volume, audioContext.currentTime);
                }
            }
            
            function getMicAccess() { return navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => { mediaStream = stream; isMicAccessGranted = true; return true; }).catch(() => { statusDisplay.textContent = 'Error: Mic access denied.'; return false; }); }
            function startScheduler() { nextBeatTime = audioContext.currentTime; metronomeScheduler(); }

            // --- MIDI ---
            function setupMIDI() {
                if(navigator.requestMIDIAccess) {
                    navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
                } else {
                    statusDisplay.textContent = "Web MIDI API not supported in this browser.";
                }
            }

            function onMIDISuccess(midiAccess) {
                const inputs = midiAccess.inputs.values();
                for(let input = inputs.next(); input && !input.done; input = inputs.next()) {
                    const option = document.createElement('option');
                    option.value = input.value.id;
                    option.text = input.value.name;
                    midiSelect.appendChild(option);
                    input.value.onmidimessage = onMIDIMessage;
                }
            }

            function onMIDIFailure() { statusDisplay.textContent = "Could not access MIDI devices."; }
            
            function onMIDIMessage(event) {
                const [command, note, velocity] = event.data;
                // Note On command
                if (command === 144 || command === 153) { // 144: Note On on Ch1, 153: Note On on Ch10
                    if (velocity > 0) {
                        const pedalIndex = note - 36; // C1 is 36
                        if (pedalIndex >= 0 && pedalIndex < NUM_PEDALS) {
                            handlePedalClick(pedalIndex);
                        }
                    }
                }
            }

            // --- Event Listeners ---
            masterStopBtn.addEventListener('click', masterStop);
            undoBtn.addEventListener('click', undo);
            metronomeToggle.addEventListener('click', () => { initAudioContext(); isMetronomeOn = !isMetronomeOn; metronomeToggle.classList.toggle('active', isMetronomeOn); if (isMetronomeOn && !schedulerTimerID) startScheduler(); });
            countInToggle.addEventListener('click', () => { isCountInEnabled = !isCountInEnabled; countInToggle.textContent = isCountInEnabled ? 'On' : 'Off'; countInToggle.classList.toggle('active', isCountInEnabled); });
            helpBtn.addEventListener('click', () => helpModal.style.display = 'block');
            closeModalBtn.addEventListener('click', () => helpModal.style.display = 'none');
            window.addEventListener('click', (e) => { if(e.target == helpModal) helpModal.style.display = 'none'; });

            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                
                if (e.shiftKey && e.code.startsWith('Digit')) {
                    const index = parseInt(e.key) - 1;
                    if (index >= 0 && index < NUM_PEDALS) { e.preventDefault(); toggleMute(index); }
                } else if (e.code.startsWith('Digit')) {
                    const index = parseInt(e.key) - 1;
                    if (index >= 0 && index < NUM_PEDALS) { e.preventDefault(); handlePedalClick(index); }
                } else if (e.code === 'Space') { e.preventDefault(); masterStop(); }
            });

            // --- Final Initialization ---
            initializePedals();
            setupMIDI();
        });
    </script>
</body>
</html>
