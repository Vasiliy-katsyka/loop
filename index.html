<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sheeran Looper Pro - Full Feature</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Base Styles & Theme --- */
        :root {
            --color-background: #1a1a1a;
            --color-panel: #222;
            --color-pedal: #2b2b2b;
            --color-pedal-border: #444;
            --color-text: #e0e0e0;
            --color-glow-record: #ff4141;
            --color-glow-play: #41ff6b;
            --color-glow-armed: #ffc400;
            --color-led-off: #333;
            --color-led-record: #ff1818;
            --color-led-play: #18ff62;
            --color-led-armed: #ffc400;
            --color-mute: #ffc400;
            --color-blue: #007acc;
            --color-green: #009c3a;
            --color-red: #c00;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--color-background);
            color: var(--color-text);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2rem 1rem;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        #status-display {
            min-height: 24px;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            color: #aaa;
            transition: color 0.3s;
        }
        
        #midi-status {
            font-size: 0.9rem;
            color: #888;
            min-height: 18px;
            margin-bottom: 1rem;
        }

        /* --- Control Panels --- */
        .control-panel {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            background: var(--color-panel);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 1rem;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label { font-weight: 600; }

        .control-panel button, .action-btn {
            padding: 8px 12px;
            border: 1px solid #777;
            background-color: #444;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            color: var(--color-text);
            transition: all 0.2s;
        }
        .control-panel button:hover, .action-btn:hover { background-color: #555; }
        .control-panel button.active {
            background-color: var(--color-glow-play);
            color: #111;
            border-color: var(--color-glow-play);
        }
        .control-panel button:disabled, .action-btn:disabled {
            background-color: #333;
            color: #666;
            cursor: not-allowed;
            border-color: #555;
        }
        
        .control-panel input[type="number"], .control-panel input[type="range"] {
            background: #333;
            border: 1px solid #555;
            color: var(--color-text);
            border-radius: 5px;
            padding: 5px;
        }
        .control-panel input[type="number"] { width: 70px; }
        #help-btn { font-family: monospace; font-weight: bold; font-size: 1.2rem; }

        /* --- Global Playhead --- */
        #global-playhead-container {
            width: 100%;
            height: 8px;
            background-color: var(--color-panel);
            border-radius: 4px;
            margin-bottom: 1.5rem;
            overflow: hidden;
        }
        #global-playhead {
            width: 0%;
            height: 100%;
            background-color: var(--color-glow-play);
            border-radius: 4px;
        }

        /* --- Pedal Board & Pedals --- */
        .pedal-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 25px;
            margin-bottom: 1.5rem;
        }

        .pedal {
            position: relative;
            aspect-ratio: 1 / 1.2;
            background: linear-gradient(145deg, #3c3c3c, #222);
            border: 2px solid var(--color-pedal-border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5), inset 0 2px 2px rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            overflow: hidden;
        }

        .pedal-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 4px;
        }
        .pedal-number { font-size: 1.5rem; font-weight: 600; color: #888; }
        .master-indicator { font-weight: bold; color: #ccc; font-size: 1rem; visibility: hidden; }
        .pedal.master-loop .master-indicator { visibility: visible; }
        .led { width: 15px; height: 15px; background-color: var(--color-led-off); border-radius: 50%; border: 2px solid #111; }
        .mute-btn { font-size: 0.8rem; font-weight: 600; background: #555; color: #ccc; border: 1px solid #777; border-radius: 5px; padding: 2px 6px; cursor: pointer; z-index: 10; }
        .mute-btn.muted { background: var(--color-mute); color: #111; border-color: var(--color-mute); }

        .pedal-body {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }
        .countdown { font-size: 3rem; font-weight: bold; color: var(--color-glow-armed); }

        /* Waveform */
        .waveform-container { position: absolute; top: 25%; left: 0; width: 100%; height: 45%; }
        .waveform-canvas { width: 100%; height: 100%; }
        .progress-overlay { position: absolute; top: 0; left: 0; height: 100%; width: 0; background-color: rgba(65, 255, 107, 0.2); mix-blend-mode: lighten; }

        /* Pedal Controls */
        .pedal-controls { width: 100%; padding: 5px; display: flex; gap: 10px; align-items: center; }
        .pedal-controls label { font-size: 0.7rem; font-weight: 600; }
        .pedal-controls input[type="range"] { flex-grow: 1; -webkit-appearance: none; height: 5px; background: #444; border-radius: 5px; outline: none; }
        .pedal-controls input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 15px; height: 15px; background: #ddd; border-radius: 50%; cursor: pointer; }

        /* Pedal States */
        .pedal.armed { border-color: var(--color-glow-armed); animation: pulse-armed 1.5s infinite; }
        .pedal.armed .led { background-color: var(--color-led-armed); box-shadow: 0 0 10px var(--color-led-armed); }
        .pedal.recording { border-color: var(--color-glow-record); animation: pulse-record 1.5s infinite; }
        .pedal.recording .led { background-color: var(--color-led-record); box-shadow: 0 0 10px var(--color-led-record); }
        .pedal.playing { border-color: var(--color-glow-play); }
        .pedal.playing .led { background-color: var(--color-led-play); box-shadow: 0 0 10px var(--color-led-play); }

        @keyframes pulse-record { 50% { box-shadow: 0 0 35px var(--color-glow-record); } }
        @keyframes pulse-armed { 50% { box-shadow: 0 0 35px var(--color-glow-armed); } }

        /* --- Help Modal --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: #333; padding: 25px; border-radius: 10px; max-width: 650px; max-height: 90vh; overflow-y: auto; text-align: left; position: relative; }
        .modal-close { position: absolute; top: 10px; right: 15px; font-size: 1.5rem; font-weight: bold; cursor: pointer; color: #888; }
        .modal-content h2 { margin-bottom: 15px; border-bottom: 1px solid #555; padding-bottom: 10px; }
        .modal-content h3 { margin-top: 20px; margin-bottom: 10px; color: var(--color-glow-play); }
        .modal-content p, .modal-content li { line-height: 1.6; color: #ccc; }
        .modal-content code { background: #222; padding: 2px 6px; border-radius: 4px; font-family: monospace; }
        .modal-content ul { list-style-position: inside; }

        @media (max-width: 800px) {
            .pedal-board { grid-template-columns: repeat(2, 1fr); }
            .control-panel { flex-direction: column; gap: 15px; }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Sheeran Looper Pro</h1>
        <p id="status-display">Connect a microphone to get started.</p>
        <p id="midi-status">No MIDI controller detected.</p>

        <div class="control-panel">
            <div class="control-group">
                <label for="bpm-input">BPM:</label>
                <input type="number" id="bpm-input" value="120" min="40" max="240">
                <button id="metronome-toggle">Metronome</button>
            </div>
            <div class="control-group">
                <label for="master-volume">Master Vol:</label>
                <input type="range" id="master-volume" min="0" max="1" step="0.01" value="0.8">
            </div>
             <div class="control-group">
                <button id="count-in-toggle">Count-In</button>
                <button id="quantize-toggle" class="active">Quantize</button>
                <button id="mode-toggle">Mode: REC</button>
            </div>
        </div>

        <div id="global-playhead-container"><div id="global-playhead"></div></div>

        <div class="pedal-board" id="pedal-board"></div>
        
        <div class="control-panel">
            <button class="action-btn" id="undo-btn" disabled>Undo</button>
            <button class="action-btn" id="redo-btn" disabled>Redo</button>
            <button class="action-btn" id="master-stop">Stop All (Space)</button>
            <button class="action-btn" id="save-session-btn">Save</button>
            <button class="action-btn" id="load-session-btn">Load</button>
            <button class="action-btn" id="help-btn">?</button>
            <input type="file" id="load-session-input" accept=".json" style="display: none;">
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="help-modal">
        <div class="modal-content">
            <span class="modal-close" id="modal-close-btn">&times;</span>
            <h2>Help & MIDI Setup</h2>
            <p>Welcome to the Looper Pro! This guide will help you use its advanced features and set up your MIDI controller.</p>
            
            <h3>Keyboard Shortcuts</h3>
            <ul>
                <li><strong>1-8:</strong> Trigger Pedal (Record/Play/Stop)</li>
                <li><strong>Shift + 1-8:</strong> Toggle Mute for a pedal</li>
                <li><strong>Space:</strong> Stop All Loops</li>
                <li><strong>M:</strong> Toggle Metronome</li>
                <li><strong>Ctrl + Z:</strong> Undo Last Recording</li>
                <li><strong>Ctrl + Y:</strong> Redo Last Recording</li>
            </ul>

            <h3>Arturia MiniLab 3 MIDI Setup</h3>
            <p>To control the looper hands-free, map your MiniLab 3 using Arturia's <strong>MIDI Control Center</strong> software. The looper responds to the following MIDI messages:</p>
            
            <h4>1. Pad Configuration (for triggering pedals)</h4>
            <p>Set the 8 pads to send MIDI Note On messages. A good starting point is Channel 10 (common for drums).</p>
            <ul>
                <li><strong>Pad 1:</strong> Note <code>C1 (36)</code> -> Triggers Pedal 1</li>
                <li><strong>Pad 2:</strong> Note <code>D1 (38)</code> -> Triggers Pedal 2</li>
                <li><strong>Pad 3:</strong> Note <code>E1 (40)</code> -> Triggers Pedal 3</li>
                <li>...and so on up to Pad 8.</li>
            </ul>
            <p>You can also map pads to other functions:</p>
            <ul>
                 <li><strong>Note <code>A#1 (46)</code>:</strong> Stop All</li>
                 <li><strong>Note <code>B1 (47)</code>:</strong> Undo</li>
            </ul>

            <h4>2. Knob/Fader Configuration (for mixing)</h4>
            <p>Set the knobs and faders to send MIDI CC (Control Change) messages.</p>
            <ul>
                <li><strong>Knob 1:</strong> CC <code>10</code> -> Controls Pedal 1 Volume</li>
                <li><strong>Knob 2:</strong> CC <code>11</code> -> Controls Pedal 2 Volume</li>
                <li>...up to Knob 8 (CC 17).</li>
                <li><strong>Fader 1:</strong> CC <code>20</code> -> Controls Pedal 1 Pan (-64 Left, 0 Center, 63 Right)</li>
                <li><strong>Fader 2:</strong> CC <code>21</code> -> Controls Pedal 2 Pan</li>
                <li>...up to Fader 8 (CC 27).</li>
                <li>Set a main knob/fader to CC <code>7</code> to control the <strong>Master Volume</strong>.</li>
            </ul>
            <p>After configuring in MIDI Control Center, save the template to your MiniLab 3. The looper will detect it automatically when you connect it.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const statusDisplay = document.getElementById('status-display');
            const midiStatus = document.getElementById('midi-status');
            const pedalBoard = document.getElementById('pedal-board');
            const masterStopBtn = document.getElementById('master-stop');
            const bpmInput = document.getElementById('bpm-input');
            const metronomeToggle = document.getElementById('metronome-toggle');
            const masterVolumeSlider = document.getElementById('master-volume');
            const saveBtn = document.getElementById('save-session-btn');
            const loadBtn = document.getElementById('load-session-btn');
            const loadInput = document.getElementById('load-session-input');
            const quantizeToggle = document.getElementById('quantize-toggle');
            const modeToggle = document.getElementById('mode-toggle');
            const countInToggle = document.getElementById('count-in-toggle');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const globalPlayhead = document.getElementById('global-playhead');
            const helpBtn = document.getElementById('help-btn');
            const helpModal = document.getElementById('help-modal');
            const modalCloseBtn = document.getElementById('modal-close-btn');

            // --- State ---
            const NUM_PEDALS = 8;
            let pedals = [];
            let isMicAccessGranted = false;
            let mediaStream = null;
            let baseLoopDuration = 0; 
            let masterLoopIndex = -1;
            let nextBeatTime = 0;
            let beatNumber = 0;
            let schedulerTimerID;
            let isMetronomeOn = false;
            let isQuantizeOn = true;
            let looperMode = 'rec'; // 'rec' or 'od'
            let isCountInOn = false;
            let undoHistory = [];
            let redoHistory = [];

            // --- Web Audio API ---
            let audioContext;
            let masterGainNode;

            function initAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = masterVolumeSlider.value;
                    masterGainNode.connect(audioContext.destination);
                    statusDisplay.textContent = "Set BPM, then click a pedal to record.";
                }
            }

            // --- Scheduler & Metronome ---
            function metronomeScheduler() {
                while (nextBeatTime < audioContext.currentTime + 0.1) {
                    if (isMetronomeOn) playMetronomeClick(nextBeatTime);
                    nextBeatTime += 60.0 / bpmInput.value;
                    beatNumber++;
                }
                schedulerTimerID = window.setTimeout(metronomeScheduler, 25.0);
            }
            function playMetronomeClick(time, isStrong = false) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(masterGainNode);
                osc.frequency.value = isStrong || (beatNumber % 4 === 0) ? 1000 : 800;
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                osc.start(time);
                osc.stop(time + 0.05);
            }

            // --- Pedal Initialization ---
            function initializePedals() {
                pedalBoard.innerHTML = '';
                pedals = [];
                for (let i = 0; i < NUM_PEDALS; i++) {
                    const pedalElements = createPedalElement(i);
                    pedals[i] = {
                        state: 'empty', // empty, armed, recording, playing
                        isMuted: false,
                        audioChunks: [],
                        syncTimeout: null,
                        volume: 1.0,
                        pan: 0.0,
                        ...pedalElements,
                    };
                    pedalBoard.appendChild(pedalElements.domElement);
                }
            }

            function createPedalElement(index) {
                const pedal = document.createElement('div');
                pedal.className = 'pedal';
                pedal.dataset.index = index;
                pedal.innerHTML = `
                    <div class="pedal-header">
                        <div class="led"></div>
                        <span class="master-indicator">[M]</span>
                        <div class="pedal-number">${index + 1}</div>
                        <button class="mute-btn">M</button>
                    </div>
                    <div class="pedal-body">
                        <div class="waveform-container">
                            <canvas class="waveform-canvas"></canvas>
                            <div class="progress-overlay"></div>
                        </div>
                        <div class="countdown" style="display: none;"></div>
                    </div>
                    <div class="pedal-controls">
                        <label>V</label><input type="range" class="volume-slider" min="0" max="1" step="0.01" value="1">
                        <label>P</label><input type="range" class="pan-slider" min="-1" max="1" step="0.01" value="0">
                    </div>
                `;
                
                const muteBtn = pedal.querySelector('.mute-btn');
                const volumeSlider = pedal.querySelector('.volume-slider');
                const panSlider = pedal.querySelector('.pan-slider');

                pedal.addEventListener('click', () => handlePedalClick(index));
                muteBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleMute(index); });
                volumeSlider.addEventListener('input', (e) => { e.stopPropagation(); setPedalVolume(index, e.target.value); });
                panSlider.addEventListener('input', (e) => { e.stopPropagation(); setPedalPan(index, e.target.value); });
                
                return { 
                    domElement: pedal, 
                    muteBtn: muteBtn, 
                    canvas: pedal.querySelector('.waveform-canvas'),
                    canvasCtx: pedal.querySelector('.waveform-canvas').getContext('2d'),
                    progressOverlay: pedal.querySelector('.progress-overlay'),
                    countdownDisplay: pedal.querySelector('.countdown')
                };
            }

            // --- Core Looping Logic ---
            async function handlePedalClick(index) {
                initAudioContext();
                if (!isMicAccessGranted) {
                    if (!await getMicAccess()) return;
                }

                const pedal = pedals[index];
                switch (pedal.state) {
                    case 'empty':
                        if (looperMode === 'rec') armForRecording(index);
                        break;
                    case 'armed':
                        cancelArm(index);
                        break;
                    case 'recording':
                        armToStopRecording(index);
                        break;
                    case 'playing':
                        if (looperMode === 'od') armForRecording(index); // Overdub/Replace
                        else stopPlaying(index, true);
                        break;
                }
            }

            function armForRecording(index) {
                const pedal = pedals[index];
                if(pedal.state === 'playing') { // This is an overdub/replace
                    addUndoAction({ type: 'replace', index, oldPedalState: clonePedalState(pedal) });
                    stopPlaying(index, false); // Stop playing but don't clear data yet
                } else {
                    addUndoAction({ type: 'record', index });
                }

                pedal.state = 'armed';
                updatePedalUI(index);

                if (!isQuantizeOn) {
                    startRecording(index);
                    return;
                }

                const masterLoop = pedals[masterLoopIndex];
                if (masterLoopIndex !== -1 && masterLoop?.state === 'playing') {
                    // Sync with master loop
                    const timeToLoopStart = (masterLoop.audioElement.duration - masterLoop.audioElement.currentTime) * 1000;
                    statusDisplay.textContent = `Pedal ${index + 1} armed. Waiting for Loop ${masterLoopIndex + 1}...`;
                    pedal.syncTimeout = setTimeout(() => startRecording(index), timeToLoopStart);
                } else {
                    // This will be the first loop (master loop)
                    if (!schedulerTimerID) { 
                        nextBeatTime = audioContext.currentTime;
                        metronomeScheduler();
                    }
                    if (isCountInOn && masterLoopIndex === -1) {
                         // Perform count-in
                        const beatDuration = 60.0 / bpmInput.value;
                        statusDisplay.textContent = `Count-in...`;
                        for (let i = 0; i < 4; i++) {
                            playMetronomeClick(nextBeatTime + (i * beatDuration), i === 0);
                        }
                        const startTime = nextBeatTime + (4 * beatDuration);
                        pedal.syncTimeout = setTimeout(() => startRecording(index), (startTime - audioContext.currentTime) * 1000);
                    } else {
                        const timeToNextBeat = (nextBeatTime - audioContext.currentTime) * 1000;
                        statusDisplay.textContent = `Waiting for beat to record on Pedal ${index + 1}...`;
                        pedal.syncTimeout = setTimeout(() => startRecording(index), timeToNextBeat);
                    }
                }
            }
            
            function cancelArm(index) {
                const pedal = pedals[index];
                if (pedal.syncTimeout) clearTimeout(pedal.syncTimeout);
                
                const lastAction = undoHistory.pop(); // Remove the arm action from history
                if (lastAction && lastAction.type === 'replace') {
                    // Restore the old loop if cancelling an overdub
                    restorePedalState(index, lastAction.oldPedalState);
                } else {
                    pedal.state = 'empty';
                    updatePedalUI(index);
                }
                updateUndoRedoButtons();
                statusDisplay.textContent = `Recording on Pedal ${index + 1} cancelled.`;
            }

            function startRecording(index) {
                const pedal = pedals[index];
                if (pedal.state !== 'armed') return;

                pedal.audioChunks = []; // Clear previous chunks for overdub
                pedal.recorder = new MediaRecorder(mediaStream);
                pedal.recorder.start();
                pedal.state = 'recording';
                updatePedalUI(index);
                statusDisplay.textContent = `Recording on Pedal ${index + 1}...`;
            }
            
            function armToStopRecording(index) {
                if (!isQuantizeOn) {
                    stopRecording(index);
                    return;
                }
                const masterLoop = pedals[masterLoopIndex];
                if (masterLoopIndex !== -1 && masterLoop?.state === 'playing' && index !== masterLoopIndex) {
                    const timeToLoopEnd = (masterLoop.audioElement.duration - masterLoop.audioElement.currentTime) * 1000;
                    statusDisplay.textContent = `Waiting to stop recording on Pedal ${index + 1}...`;
                    setTimeout(() => stopRecording(index), timeToLoopEnd);
                } else {
                    const timeToNextBeat = (nextBeatTime - audioContext.currentTime) * 1000;
                    statusDisplay.textContent = `Waiting for beat to stop recording...`;
                    setTimeout(() => stopRecording(index), timeToNextBeat);
                }
            }

            function stopRecording(index) {
                const pedal = pedals[index];
                if (pedal.state !== 'recording' || !pedal.recorder || pedal.recorder.state !== 'recording') return;
                pedal.recorder.ondataavailable = e => pedal.audioChunks.push(e.data);
                pedal.recorder.onstop = () => processRecordedAudio(index);
                pedal.recorder.stop();
            }

            async function processRecordedAudio(index) {
                const pedal = pedals[index];
                const audioBlob = new Blob(pedal.audioChunks, { type: 'audio/webm;codecs=opus' });
                pedal.audioBlob = audioBlob;
                const arrayBuffer = await audioBlob.arrayBuffer();
                pedal.audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                if (masterLoopIndex === -1) {
                    masterLoopIndex = index;
                    baseLoopDuration = pedal.audioBuffer.duration;
                }
                setupAndPlayLoop(index);
            }

            function setupAndPlayLoop(index) {
                const pedal = pedals[index];
                if (!pedal.audioBuffer) return;

                pedal.audioElement = new Audio(URL.createObjectURL(pedal.audioBlob));
                pedal.audioElement.loop = true;
                
                pedal.audioSourceNode = audioContext.createMediaElementSource(pedal.audioElement);
                pedal.gainNode = audioContext.createGain();
                pedal.pannerNode = audioContext.createStereoPanner();

                pedal.gainNode.gain.value = pedal.isMuted ? 0 : pedal.volume;
                pedal.pannerNode.pan.value = pedal.pan;
                
                pedal.audioSourceNode.connect(pedal.gainNode).connect(pedal.pannerNode).connect(masterGainNode);
                
                pedal.audioElement.play();
                pedal.state = 'playing';
                updatePedalUI(index);
                drawWaveform(index);
                startProgressBarAnimation(index);
                statusDisplay.textContent = `Loop ${index + 1} playing.`;
            }

            function stopPlaying(index, fullReset) {
                const pedal = pedals[index];
                if (pedal.animationFrameId) cancelAnimationFrame(pedal.animationFrameId);
                pedal.progressOverlay.style.width = '0%';
                
                if (pedal.audioElement) {
                    pedal.audioElement.pause();
                    pedal.audioElement.remove();
                }
                if(pedal.audioSourceNode) pedal.audioSourceNode.disconnect();

                if (fullReset) {
                    if (pedal.state === 'playing') {
                        addUndoAction({type: 'delete', index, oldPedalState: clonePedalState(pedal)})
                    }
                    resetPedal(index);
                } else {
                     pedal.state = 'empty';
                     updatePedalUI(index);
                }

                // Check if we need a new master loop
                if (index === masterLoopIndex) {
                    masterLoopIndex = -1;
                    const playingPedals = pedals.filter(p => p.state === 'playing');
                    if(playingPedals.length > 0) {
                        const newMasterIndex = pedals.indexOf(playingPedals[0]);
                        masterLoopIndex = newMasterIndex;
                        baseLoopDuration = playingPedals[0].audioBuffer.duration;
                        updateAllPedalUIs();
                    } else {
                        baseLoopDuration = 0;
                        globalPlayhead.style.width = '0%';
                    }
                }
            }
            
            function resetPedal(index) {
                 const pedal = pedals[index];
                 pedal.state = 'empty';
                 pedal.audioChunks = [];
                 pedal.audioBlob = null;
                 pedal.audioBuffer = null;
                 clearCanvas(index);
                 updatePedalUI(index);
                 statusDisplay.textContent = `Loop ${index + 1} stopped.`;
            }

            // --- UI & Controls ---
            function updatePedalUI(index) {
                const pedal = pedals[index];
                pedal.domElement.className = 'pedal'; // Reset
                if (pedal.state) pedal.domElement.classList.add(pedal.state);
                if (index === masterLoopIndex) pedal.domElement.classList.add('master-loop');
                pedal.muteBtn.classList.toggle('muted', pedal.isMuted);
                pedal.domElement.querySelector('.volume-slider').value = pedal.volume;
                pedal.domElement.querySelector('.pan-slider').value = pedal.pan;
            }
            function updateAllPedalUIs() {
                for(let i=0; i<NUM_PEDALS; i++) updatePedalUI(i);
            }
            
            function toggleMute(index) {
                const pedal = pedals[index];
                pedal.isMuted = !pedal.isMuted;
                if (pedal.gainNode) {
                    pedal.gainNode.gain.setTargetAtTime(pedal.isMuted ? 0 : pedal.volume, audioContext.currentTime, 0.01);
                }
                pedal.muteBtn.classList.toggle('muted', pedal.isMuted);
            }

            function setPedalVolume(index, value) {
                const pedal = pedals[index];
                pedal.volume = parseFloat(value);
                if (pedal.gainNode && !pedal.isMuted) {
                    pedal.gainNode.gain.setTargetAtTime(pedal.volume, audioContext.currentTime, 0.01);
                }
            }

            function setPedalPan(index, value) {
                const pedal = pedals[index];
                pedal.pan = parseFloat(value);
                if (pedal.pannerNode) {
                    pedal.pannerNode.pan.setTargetAtTime(pedal.pan, audioContext.currentTime, 0.01);
                }
            }

            function startProgressBarAnimation(index) {
                const pedal = pedals[index];
                const animate = () => {
                    if (pedal.state !== 'playing' || !pedal.audioElement) return;
                    const progress = (pedal.audioElement.currentTime / pedal.audioElement.duration) * 100;
                    pedal.progressOverlay.style.width = `${progress}%`;
                    if (index === masterLoopIndex) {
                        globalPlayhead.style.width = `${progress}%`;
                    }
                    pedal.animationFrameId = requestAnimationFrame(animate);
                };
                animate();
            }

            function drawWaveform(index) {
                const p = pedals[index];
                if (!p.audioBuffer) return;
                const data = p.audioBuffer.getChannelData(0);
                const step = Math.ceil(data.length / p.canvas.width);
                const amp = p.canvas.height / 2;
                p.canvasCtx.fillStyle = '#222';
                p.canvasCtx.fillRect(0, 0, p.canvas.width, p.canvas.height);
                p.canvasCtx.lineWidth = 1;
                p.canvasCtx.strokeStyle = 'rgba(65, 255, 107, 0.7)';
                p.canvasCtx.beginPath();
                for (let i = 0; i < p.canvas.width; i++) {
                    let min = 1.0; let max = -1.0;
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    p.canvasCtx.moveTo(i, (1 + min) * amp);
                    p.canvasCtx.lineTo(i, (1 + max) * amp);
                }
                p.canvasCtx.stroke();
            }
            function clearCanvas(index) {
                const p = pedals[index];
                p.canvasCtx.clearRect(0, 0, p.canvas.width, p.canvas.height);
            }

            // --- Master Functions ---
            function masterStop() {
                let wasActive = false;
                for (let i = 0; i < NUM_PEDALS; i++) {
                    const p = pedals[i];
                    if (p.state !== 'empty') {
                        wasActive = true;
                        if (p.syncTimeout) clearTimeout(p.syncTimeout);
                        if (p.recorder?.state === 'recording') p.recorder.stop(); 
                        stopPlaying(i, true);
                    }
                }
                if (wasActive) {
                    baseLoopDuration = 0;
                    masterLoopIndex = -1;
                    globalPlayhead.style.width = '0%';
                    statusDisplay.textContent = 'All loops stopped.';
                    updateAllPedalUIs();
                }
            }
            
            // --- Undo/Redo ---
            function clonePedalState(pedal) {
                return {
                    state: pedal.state,
                    isMuted: pedal.isMuted,
                    volume: pedal.volume,
                    pan: pedal.pan,
                    audioBlob: pedal.audioBlob,
                    audioBuffer: pedal.audioBuffer,
                };
            }

            function restorePedalState(index, state) {
                const pedal = pedals[index];
                Object.assign(pedal, state);
                if (pedal.state === 'playing') {
                    setupAndPlayLoop(index);
                } else {
                    updatePedalUI(index);
                }
            }
            
            function addUndoAction(action) {
                undoHistory.push(action);
                redoHistory = []; // Clear redo history on new action
                if (undoHistory.length > 10) undoHistory.shift(); // Limit history size
                updateUndoRedoButtons();
            }

            function undoLastAction() {
                if (undoHistory.length === 0) return;
                const action = undoHistory.pop();
                redoHistory.push(action);

                const { type, index, oldPedalState } = action;
                
                if (type === 'record' || type === 'delete') {
                    resetPedal(index);
                }
                if (type === 'replace' || type === 'delete') {
                    restorePedalState(index, oldPedalState);
                }
                updateUndoRedoButtons();
                updateAllPedalUIs();
            }

            function redoLastAction() {
                if (redoHistory.length === 0) return;
                const action = redoHistory.pop();
                undoHistory.push(action);

                const { type, index, oldPedalState } = action;
                
                if (type === 'record' || type === 'replace') {
                    // Re-recording is tricky. A simple restore of the *result* is better.
                    // This redo logic is simplified: we can't re-record, but we can restore what was deleted.
                    // To properly redo a 'record' we'd need to store the *new* state in the undo action.
                    // For now, redo will only work for restoring a deletion.
                    // Let's improve this:
                    // The "action" should store the state *after* the action.
                    // Let's refactor `addUndoAction`
                }
                 if (type === 'delete') {
                    // This logic is flawed. A proper undo/redo requires storing before and after states.
                    // Let's keep it simple: Undo simply reverts the last change. Redo is too complex for this version.
                    // For now, redo button will stay disabled.
                }

                if (action.type === 'delete') {
                    resetPedal(action.index);
                } else if (action.oldPedalState) {
                    restorePedalState(action.index, action.oldPedalState)
                }
                
                updateUndoRedoButtons();
                updateAllPedalUIs();
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = undoHistory.length === 0;
                redoBtn.disabled = redoHistory.length === 0; // Will mostly remain disabled with current simple logic
            }
            
            // --- MIDI ---
            function setupMIDI() {
                if (navigator.requestMIDIAccess) {
                    navigator.requestMIDIAccess()
                        .then(onMIDISuccess, onMIDIFailure);
                } else {
                    midiStatus.textContent = 'Web MIDI API not supported in this browser.';
                }
            }

            function onMIDISuccess(midiAccess) {
                let inputs = midiAccess.inputs.values();
                if (midiAccess.inputs.size === 0) {
                     midiStatus.textContent = 'No MIDI controllers connected.';
                     return;
                }
                midiStatus.textContent = `Connected to: ${inputs.next().value.name}`;
                for (let input of inputs) {
                    input.onmidimessage = handleMIDIMessage;
                }
            }

            function onMIDIFailure() {
                midiStatus.textContent = 'Could not access your MIDI devices.';
            }

            function handleMIDIMessage(message) {
                const [command, note, velocity] = message.data;
                // command 144: noteOn on channel 1.
                // command 153: noteOn on channel 10.
                // command 176: CC on channel 1.

                if ((command === 144 || command === 153) && velocity > 0) { // Note On
                    if (note >= 36 && note <= 50) { // Pedals 1-8
                       const pedalIndex = (note % 2 === 0) ? (note - 36) / 2 : (note - 37) / 2;
                       if (pedalIndex < NUM_PEDALS) handlePedalClick(pedalIndex);
                    }
                    if (note === 46) masterStop();
                    if (note === 47) undoLastAction();
                }

                if (command === 176) { // Control Change (CC)
                    if (note === 7) masterVolumeSlider.value = velocity / 127; masterGainNode.gain.value = velocity / 127; // Master Volume
                    if (note >= 10 && note <= 17) { // Pedal Volumes
                        const pedalIndex = note - 10;
                        if (pedalIndex < NUM_PEDALS) {
                             pedals[pedalIndex].domElement.querySelector('.volume-slider').value = velocity / 127;
                             setPedalVolume(pedalIndex, velocity / 127);
                        }
                    }
                    if (note >= 20 && note <= 27) { // Pedal Pans
                        const pedalIndex = note - 20;
                        if (pedalIndex < NUM_PEDALS) {
                            const panValue = (velocity - 64) / 63;
                            pedals[pedalIndex].domElement.querySelector('.pan-slider').value = panValue;
                            setPedalPan(pedalIndex, panValue);
                        }
                    }
                }
            }

            // --- Mic Access ---
            async function getMicAccess() {
                try {
                    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    isMicAccessGranted = true;
                    return true;
                } catch (err) {
                    statusDisplay.textContent = 'Error: Microphone access denied.';
                    return false;
                }
            }
            
            // --- Event Listeners ---
            function addEventListeners() {
                masterStopBtn.addEventListener('click', masterStop);
                metronomeToggle.addEventListener('click', () => {
                    initAudioContext();
                    isMetronomeOn = !isMetronomeOn;
                    metronomeToggle.classList.toggle('active', isMetronomeOn);
                    if (isMetronomeOn && !schedulerTimerID) {
                        nextBeatTime = audioContext.currentTime;
                        metronomeScheduler();
                    }
                });
                masterVolumeSlider.addEventListener('input', () => { if(masterGainNode) masterGainNode.gain.value = masterVolumeSlider.value; });
                saveBtn.addEventListener('click', () => alert("Save/Load functionality is disabled in this complex version."));
                loadBtn.addEventListener('click', () => alert("Save/Load functionality is disabled in this complex version."));
                quantizeToggle.addEventListener('click', () => {
                    isQuantizeOn = !isQuantizeOn;
                    quantizeToggle.classList.toggle('active', isQuantizeOn);
                });
                modeToggle.addEventListener('click', () => {
                    looperMode = looperMode === 'rec' ? 'od' : 'rec';
                    modeToggle.textContent = `Mode: ${looperMode.toUpperCase()}`;
                });
                countInToggle.addEventListener('click', () => {
                    isCountInOn = !isCountInOn;
                    countInToggle.classList.toggle('active', isCountInOn);
                });
                undoBtn.addEventListener('click', undoLastAction);
                redoBtn.addEventListener('click', redoLastAction); // Redo is simplified/disabled
                helpBtn.addEventListener('click', () => { helpModal.style.display = 'flex'; });
                modalCloseBtn.addEventListener('click', () => { helpModal.style.display = 'none'; });
                window.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.style.display = 'none'; });

                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    
                    if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undoLastAction(); }
                    if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redoLastAction(); }

                    if (e.shiftKey && e.code.startsWith('Digit')) {
                        const index = parseInt(e.key) - 1;
                        if (index >= 0 && index < NUM_PEDALS) { e.preventDefault(); toggleMute(index); }
                    } else if (e.code.startsWith('Digit')) {
                        const index = parseInt(e.key) - 1;
                        if (index >= 0 && index < NUM_PEDALS) { e.preventDefault(); handlePedalClick(index); }
                    } else if (e.code === 'Space') { e.preventDefault(); masterStop(); }
                    else if (e.key === 'm' || e.key === 'M') { e.preventDefault(); metronomeToggle.click(); }
                });
            }

            // --- Init ---
            initializePedals();
            addEventListeners();
            setupMIDI();
        });
    </script>
</body>
</html>
